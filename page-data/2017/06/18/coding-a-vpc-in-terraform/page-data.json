{"componentChunkName":"component---src-templates-blog-post-js","path":"/2017/06/18/coding-a-vpc-in-terraform","webpackCompilationHash":"5922713c92655645bc49","result":{"data":{"markdownRemark":{"id":"bf16ef2f-a045-59bb-a29d-c4de45f370f3","excerpt":"One of the common uses network setups in AWS is called Scenario 2: VPC with Public and Private Subnets. This is a that defines a Virtual…","html":"<p>One of the common uses network setups in AWS is called <a href=\"http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Scenario2.html\">Scenario 2: VPC with Public and Private Subnets</a>. This is a that defines a Virtual Private Cloud (VPC), public subnets and private subnets. Setting up this infrastructure can be done via the AWS console or via cloud formation scripting. However, I prefer the tool <a href=\"https://www.terraform.io/\">Terraform</a> in which you can manage your infrastructure as code with a declarative language that supports building, changing and versioning your cloud in a modular way.</p>\n<p>In this article I will describe how you can create a VPC with a public and private subnet on AWS using terraform. I will describe the setup step by step and I will show how to encapsulate all logic to one re-usable module.</p>\n<blockquote>\n<p><a href=\"http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Subnets.html\">Why we need subnets.</a> When you create a VPC, it spans all the Availability Zones in the region. After creating a VPC, you can add one or more subnets in each Availability Zone. When you create a subnet, you specify the CIDR block for the subnet, which is a subset of the VPC CIDR block. Each subnet must reside entirely within one Availability Zone and cannot span zones. Availability Zones are distinct locations that are engineered to be isolated from failures in other Availability Zones. By launching instances in separate Availability Zones, you can protect your applications from the failure of a single location.</p>\n</blockquote>\n<p>Before you can start, you need an AWS account with sufficient rights (admin), and you should create a <code class=\"language-text\">AWS_ACCESS_KEY_ID</code> and <code class=\"language-text\">AWS_SECRET_ACCESS_KEY</code> to be able to access your account programmatically.</p>\n<h2 id=\"setting-up-your-system\"><a href=\"#setting-up-your-system\" aria-label=\"setting up your system permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Setting up your system.</h2>\n<p>The easiest way to use terraform is via docker. In that case you do not need any locally isntalled tools. We simply create a file called <code class=\"language-text\">.aws</code> where we put the AWS key and secret to athentication API calls, as shown below:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">AWS_ACCESS_KEY_ID=&lt;KEY&gt;\nAWS_SECRET_ACCESS_KEY=&lt;SECRET&gt;</code></pre></div>\n<h2 id=\"creating-a-vpc-part-1\"><a href=\"#creating-a-vpc-part-1\" aria-label=\"creating a vpc part 1 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Creating a VPC part 1</h2>\n<p>All code for part 1 is available on <a href=\"https://github.com/040code/blog_terraform-aws-vpc\">github</a></p>\n<p>By default, terraform expects the configuration in a file called <code class=\"language-text\">main.tf</code>. Create the file and add the terraform provide for Amazon:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># main.tf\nprovider &quot;aws&quot; {\n  region = &quot;eu-west-1&quot;\n}</code></pre></div>\n<p>We are now ready to, step-by-step, add the terraform resources to create the VPC setup. First, have a look on the VPC setup as shown in the picture below.\n<a href=\"#\">\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 75.74525745257452%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsSAAALEgHS3X78AAAClUlEQVQ4y4VU227TQBD1V/LEF/Al/AM/AI8ICShIIEQELbmUpLm5pEnaNI6dxnd77d21fZjZtFEkoKw0sj1enzl7zowt0BLnHyEGnyGzEGVZ3oc8ihJSSiilUFUVmqb5Z1h1XaMUOQpvAXH2CrIQ+2AQcy2guADda0WgBPzYslA3oF3w73wM+xNKNZA1IEUGWdXErIQqcmhZoKJQVDwXAr7vw57amF/NcWnb8DwPgvKWVCUKkcKPAyRFAblzkHbfQhG0XrbRxBsoqpkTEB83jUK4rotOp4Pvp6dYr9dYLhbodXvm3pq4E1ys+jiZfkDvaoBZvwfv+RMUNyPctV/DGX9DTMeOqKAmDcssNky20RZu6JIUJZIkgRt5SLMUltbSMAySEFor5GSCt3FwffMLq3CH2WaBdeQiJTAiahRi8Y8XP9dN/aBhjZp0KqgSu8jLDwIMR2NEQWieFTEp5m1oAq7sLyY3mUwxuBgeAHFfiFymNiCWWzLlZ29oQLlNWK+qFigbhXA5gvf1JYLlGLfvX0AojdFohLMf7T/YWg0x1KRRngtwC/FitmkS4FNric7ANblEUMuQ67ng0xQmF8cxHMcxoSttSBwAWeiHagy+9W7x5uQST5+9I9as895lmSWmRbqdLlqtFubzOWazGc5753uXDwwJ0OhhAHOEUYQg2OF2vSX3ciMDy5HFoXH12rnGYr1ATu/cnQt7ZWNz5x4zLMjlPW12eTYdI0tiU4TdZ7CadaW9FR1dV5SrOEeTRr2cSRoE8sIAyjw1k6FLYcB1GmJ3NUZJlRXleUI0jZ6ZmLJ4fPTYCK7OwQz5mY80pXEKwpCcrk1eMkNqQt73/5/DfZvwh+Zj+gGsVivj4nH+4d2h9/6yfgM2gX0ML7ZrjwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;\"></span>\n  <picture>\n        <source srcset=\"/static/8b78637f33297f5081063556e8f76152/cc182/nat-gateway-diagram.webp 148w,\n/static/8b78637f33297f5081063556e8f76152/f7e40/nat-gateway-diagram.webp 295w,\n/static/8b78637f33297f5081063556e8f76152/1a2f4/nat-gateway-diagram.webp 590w,\n/static/8b78637f33297f5081063556e8f76152/4eead/nat-gateway-diagram.webp 738w\" sizes=\"(max-width: 590px) 100vw, 590px\" type=\"image/webp\">\n        <source srcset=\"/static/8b78637f33297f5081063556e8f76152/cf440/nat-gateway-diagram.png 148w,\n/static/8b78637f33297f5081063556e8f76152/d2d38/nat-gateway-diagram.png 295w,\n/static/8b78637f33297f5081063556e8f76152/b9e4f/nat-gateway-diagram.png 590w,\n/static/8b78637f33297f5081063556e8f76152/2bf51/nat-gateway-diagram.png 738w\" sizes=\"(max-width: 590px) 100vw, 590px\" type=\"image/png\">\n        <img class=\"gatsby-resp-image-image\" src=\"/static/8b78637f33297f5081063556e8f76152/b9e4f/nat-gateway-diagram.png\" alt=\"nat-gateway-diagram\" title=\"nat-gateway-diagram\" loading=\"lazy\">\n      </picture>\n    </span>\n</a></p>\n<p>We will start by creating the VPC itself: add the following snippet to your <code class=\"language-text\">main.tf</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">resource &quot;aws_vpc&quot; &quot;vpc&quot; {\n  cidr_block           = &quot;10.0.0.0/16&quot;\n  enable_dns_support   = true\n  enable_dns_hostnames = true\n\n  tags {\n    label = &quot;blog&quot;\n  }\n}</code></pre></div>\n<p>Before we make the change effective we run a <code class=\"language-text\">terraform plan</code> to inspect the planned changes. You can install terraform locally or run the commands in a docker container. The docker command will export the AWS credentials to the container, mount the current directory to <code class=\"language-text\">/data</code> in the container, and set <code class=\"language-text\">/data</code> as working directory to ensure the container will execute the <code class=\"language-text\">terraform plan</code> command on the directory that contains the terraform files.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker run -it --env-file ./.aws  -v $(pwd):/data -w /data \\\n  hashicorp/terraform:0.9.8 plan</code></pre></div>\n<p>After executing the plan command, you should see output similar to:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">+ aws_vpc.vpc\n    assign_generated_ipv6_cidr_block: &quot;false&quot;\n    cidr_block:                       &quot;10.0.0.0/16&quot;\n    default_network_acl_id:           &quot;&lt;computed&gt;&quot;\n    default_route_table_id:           &quot;&lt;computed&gt;&quot;\n    default_security_group_id:        &quot;&lt;computed&gt;&quot;\n    dhcp_options_id:                  &quot;&lt;computed&gt;&quot;\n    enable_classiclink:               &quot;&lt;computed&gt;&quot;\n    enable_dns_hostnames:             &quot;true&quot;\n    enable_dns_support:               &quot;true&quot;\n    instance_tenancy:                 &quot;&lt;computed&gt;&quot;\n    ipv6_association_id:              &quot;&lt;computed&gt;&quot;\n    ipv6_cidr_block:                  &quot;&lt;computed&gt;&quot;\n    main_route_table_id:              &quot;&lt;computed&gt;&quot;\n    tags.%:                           &quot;1&quot;\n    tags.label:                       &quot;blog&quot;\n\n\nPlan: 1 to add, 0 to change, 0 to destroy.</code></pre></div>\n<p>This looks correct, so we can apply the change to create the VPC by running <code class=\"language-text\">terraform apply</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">docker run -it --env-file ./.aws  -v $(pwd):/data -w /data \\\n  hashicorp/terraform:0.9.8 apply</code></pre></div>\n<p>You can go VPC via the AWS console, where you should now see a VPC in the list named <code class=\"language-text\">blog</code>. Now we have the VPC, we create a public and private subnet by adding the following to the main.tf.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">resource &quot;aws_subnet&quot; &quot;public_subnet_a&quot; {\n  vpc_id                  = &quot;${aws_vpc.vpc.id}&quot;\n  cidr_block              = &quot;10.0.0.0/24&quot;\n  availability_zone       = &quot;eu-west-1a&quot;\n  map_public_ip_on_launch = false\n\n  tags {\n    Name = &quot;blog&quot;\n  }\n}\n\nresource &quot;aws_subnet&quot; &quot;private_subnet_a&quot; {\n  vpc_id                  = &quot;${aws_vpc.vpc.id}&quot;\n  cidr_block              = &quot;10.0.1.0/24&quot;\n  availability_zone       = &quot;eu-west-1a&quot;\n\n  tags {\n    Name = &quot;blog&quot;\n  }\n}</code></pre></div>\n<p>Run now <code class=\"language-text\">terraform plan</code> again, it will show that the resources will be added, one for each subnet. Apply the change using <code class=\"language-text\">terraform apply</code> and inspect your changes again via the VPC section in the AWS console.</p>\n<p>Next, we connect the public subnet via an <em>internet gateway</em>. Create a routing table and an internet gateway. And a <em>aws<em>route</em>table_association</em> to create an association between a subnet and routing table. Update your <code class=\"language-text\">main.tf</code> with the snippet below, and run a plan and apply.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">resource &quot;aws_internet_gateway&quot; &quot;internet_gateway&quot; {\n  vpc_id = &quot;${aws_vpc.vpc.id}&quot;\n}\n\nresource &quot;aws_route_table&quot; &quot;public_routetable&quot; {\n  vpc_id = &quot;${aws_vpc.vpc.id}&quot;\n\n  route {\n    cidr_block = &quot;0.0.0.0/0&quot;\n    gateway_id = &quot;${aws_internet_gateway.internet_gateway.id}&quot;\n  }\n\n  tags {\n    label = &quot;blog&quot;\n  }\n}\n\nresource &quot;aws_route_table_association&quot; &quot;public_subnet_a&quot; {\n  subnet_id      = &quot;${aws_subnet.public_subnet_a.id}&quot;\n  route_table_id = &quot;${aws_route_table.public_routetable.id}&quot;\n}</code></pre></div>\n<p>We are now able to deploy an application to the public subnet and make it accessible via a security group. However, it is not yet possible to route traffic to the private subnet or let instances on the private subnet connect to internet. To do so, we add a NAT gateway and connect the gateway via a route table to the private subnet. The NAT gateway requires an elastic IP, which we will create first. Add the next terraform snippet to your <code class=\"language-text\">main.tf</code> and run a <code class=\"language-text\">plan</code> and <code class=\"language-text\">apply</code> to inspect and make the changes effective.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">resource &quot;aws_eip&quot; &quot;nat&quot; {\n  vpc = true\n}\n\nresource &quot;aws_nat_gateway&quot; &quot;nat&quot; {\n  allocation_id = &quot;${aws_eip.nat.id}&quot;\n  subnet_id     = &quot;${aws_subnet.public_subnet_a.id}&quot;\n}\n\nresource &quot;aws_route_table&quot; &quot;private_routetable&quot; {\n  vpc_id = &quot;${aws_vpc.vpc.id}&quot;\n\n  route {\n    cidr_block     = &quot;0.0.0.0/0&quot;\n    nat_gateway_id = &quot;${aws_nat_gateway.nat.id}&quot;\n  }\n\n  tags {\n    label = &quot;blog&quot;\n  }\n}\n\nresource &quot;aws_route_table_association&quot; &quot;private_subnet_a&quot; {\n  subnet_id      = &quot;${aws_subnet.private_subnet_a.id}&quot;\n  route_table_id = &quot;${aws_route_table.private_routetable.id}&quot;\n}</code></pre></div>\n<p>Setting up the VPC with subnets is quite verbose, and imagine then when you must support more availability zones, the code will almost double per zone. So we refactor it to a generic module to support the multiple subnets that are available in a zone.</p>\n<h2 id=\"creating-a-vpc-part-2\"><a href=\"#creating-a-vpc-part-2\" aria-label=\"creating a vpc part 2 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Creating a VPC part 2</h2>\n<p>I have rewritten the code showed above to a generic module. With this model, it is easy to create a VPC with all availability zones per zone, and private subnets can be enabled on demand.</p>\n<blockquote>\n<p><a href=\"https://www.terraform.io/docs/modules/usage.html\">Modules in terraform</a> are self-contained packages of gerraform configurations that are managed as a group. Modules are used to create reusable components, improve organization, and to treat pieces of infrastructure as a black box.</p>\n</blockquote>\n<p>I will not describe all code in the module again but only will pay attention to the significant changes I made. In the code above the zone, availability zone where hard coded. This will not work in a generic module. A common way to solve this in terraform is by creating a map where a zone is mapped to a list of availability zondes. By passing the zone to the moudle, the module can find out which availability zones there are. A default map is available in the module but can be ovewritten as follow:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">availability_zones = {\n  eu-west-1 = [&quot;eu-west-1a&quot;, &quot;eu-west-1b&quot;, &quot;eu-west-1c&quot;]\n}</code></pre></div>\n<p>The cdir block in the code show above was hard coded, but terraform contains a function to calculate the cdir block. In the module I use the terraform <a href=\"https://www.terraform.io/docs/configuration/interpolation.html#cidrsubnet-iprange-newbits-netnum-\">function</a> <code class=\"language-text\">cidrsubnet()</code> to calculate the cdir block.</p>\n<p>Now only one problem needs to be solved in order to create a generic module: how can we create a AWS resource for each element in a list? Do we create subnet or route table association for each availability zone? Or how can we avoid creating a private subnet at all? The solution is to use the <code class=\"language-text\">count</code> variable in a module to iterate over the list of availability zones, which is available on my <a href=\"https://github.com/npalm/tf-aws-vpc.git\">github</a>. We can now create a VPC similar to the one above with just a few line of code. Add the following lines to your terraform script to create a VPC.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">module &quot;vpc&quot; {\n  source = &quot;git::https://github.com/npalm/tf-aws-vpc.git&quot;\n\n  key        = &quot;blog&quot;\n  aws_region = &quot;eu-west-1&quot;\n}</code></pre></div>\n<p>It is possible to overwrite module variables with default to get more control, see the ezample below:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">module &quot;vpc&quot; {\n  source = &quot;git::https://github.com/npalm/tf-aws-vpc.git&quot;\n\n  key        = &quot;blog&quot;\n  aws_region = &quot;eu-west-1&quot;\n\n  create_private_hosted_zone = &quot;false&quot;\n  create_private_subnets     = &quot;false&quot;\n  cidr_block = &quot;10.0.0.0/16&quot;\n\n  // example to override default availability_zones\n  availability_zones = {\n    eu-west-1 = [&quot;eu-west-1a&quot;, &quot;eu-west-1c&quot;]\n  }\n}</code></pre></div>","frontmatter":{"title":"Coding a VPC in Terraform","subtitle":"A terraform module for a VPC with Private Subnets","date":"2017-06-18","slug":"2017/06/18/coding-a-vpc-in-terraform","language":null,"tags":["aws","terraform"],"authors":["niek"],"comments":false,"cover":{"publicURL":"/static/piazza-4e7cab4e75f74c20f03a8b093b0c4b34.jpg"},"coverLink":null,"coverDescription":null,"imageTw":{"publicURL":"/static/2017-06-18-coding-a-vpc-in-terraform-tw-77c0dbeee7969dd37c02e1b493b0555c.png"},"imageFb":{"publicURL":"/static/2017-06-18-coding-a-vpc-in-terraform-fb-863703b2009a9211abe4b344e40f6394.png"},"asciinema":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"2017/06/18/coding-a-vpc-in-terraform","previous":{"frontmatter":{"title":"GraphQL","slug":"2017/05/20/graphql","type":"post","tags":["graphql"],"authors":["niek"]}},"next":{"frontmatter":{"title":"Visualising Bézier Curves","slug":"2017/07/01/visualising-bezier-curves","type":"post","tags":["clojure","bézier","functional","incanter"],"authors":["maarten"]}}}}}